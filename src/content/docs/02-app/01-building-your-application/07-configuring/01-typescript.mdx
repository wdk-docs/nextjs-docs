---
title: TypeScript
description: Next.js provides a TypeScript-first development experience for building your React application.
---

{/* The content of this doc is shared between the app and pages router. You can use the `<PagesOnly>Content</PagesOnly>` component to add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. */}

Next.js ä¸ºæ„å»º React åº”ç”¨ç¨‹åºæä¾›äº† TypeScript ç¬¬ä¸€æ¬¡å¼€å‘ä½“éªŒã€‚

å®ƒå†…ç½® TypeScript æ”¯æŒï¼Œå¯è‡ªåŠ¨å®‰è£…å¿…è¦çš„è½¯ä»¶åŒ…å¹¶é…ç½®æ­£ç¡®çš„è®¾ç½®ã€‚

<AppOnly>

ä»¥åŠç”¨äºç¼–è¾‘å™¨çš„[TypeScript æ’ä»¶](#typescript-plugin)ã€‚

> **ğŸ¥ çœ‹:** äº†è§£å†…ç½® TypeScript æ’ä»¶ â†’ [YouTubeï¼ˆ3 åˆ†é’Ÿï¼‰](https://www.youtube.com/watch?v=pqMqn9fKEf8)

</AppOnly>

## æ–°é¡¹ç›®

`create-next-app` ç°åœ¨é»˜è®¤æƒ…å†µä¸‹é™„å¸¦ TypeScriptã€‚

```bash filename="Terminal"
npx create-next-app@latest
```

## ç°æœ‰é¡¹ç›®

Add TypeScript to your project by renaming a file to `.ts` / `.tsx`. Run `next dev` and `next build` to automatically install the necessary dependencies and add a `tsconfig.json` file with the recommended config options.

If you already had a `jsconfig.json` file, copy the `paths` compiler option from the old `jsconfig.json` into the new `tsconfig.json` file, and delete the old `jsconfig.json` file.

<AppOnly>

## TypeScript æ’ä»¶

Next.js åŒ…æ‹¬ä¸€ä¸ªè‡ªå®šä¹‰çš„ TypeScript æ’ä»¶å’Œç±»å‹æ£€æŸ¥å™¨ï¼ŒVSCode å’Œå…¶ä»–ä»£ç ç¼–è¾‘å™¨å¯ä»¥ä½¿ç”¨å®ƒè¿›è¡Œé«˜çº§ç±»å‹æ£€æŸ¥å’Œè‡ªåŠ¨å®Œæˆã€‚

æ‚¨å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼åœ¨ VS Code ä¸­å¯ç”¨æ’ä»¶ï¼š

1. æ‰“å¼€å‘½ä»¤é€‰é¡¹æ¿ (`Ctrl/âŒ˜` + `Shift` + `P`)
2. æ­£åœ¨æœç´¢"TypeScript: Select TypeScript Version"
3. é€‰æ‹© "Use Workspace Version"

<Image
  alt="TypeScript Command Palette"
  srclight="/docs/light/typescript-command-palette.png"
  srcdark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

ç°åœ¨ï¼Œåœ¨ç¼–è¾‘æ–‡ä»¶æ—¶ï¼Œå°†å¯ç”¨è‡ªå®šä¹‰æ’ä»¶ã€‚è¿è¡Œ`next build`æ—¶ï¼Œå°†ä½¿ç”¨è‡ªå®šä¹‰ç±»å‹æ£€æŸ¥å™¨ã€‚

### æ’ä»¶åŠŸèƒ½

TypeScript æ’ä»¶å¯ä»¥å¸®åŠ©ï¼š

- å¦‚æœä¼ é€’äº†[æ®µé…ç½®é€‰é¡¹](/docs/app/api-reference/file-conventions/route-segment-config)çš„æ— æ•ˆå€¼ï¼Œåˆ™å‘å‡ºè­¦å‘Šã€‚
- æ˜¾ç¤ºå¯ç”¨é€‰é¡¹å’Œä¸Šä¸‹æ–‡ä¸­çš„æ–‡æ¡£ã€‚
- ç¡®ä¿æ­£ç¡®ä½¿ç”¨`use client`æŒ‡ä»¤ã€‚
- ç¡®ä¿å®¢æˆ·ç«¯æŒ‚é’©ï¼ˆå¦‚`useState`ï¼‰ä»…åœ¨å®¢æˆ·ç«¯ç»„ä»¶ä¸­ä½¿ç”¨ã€‚

> **å¾ˆé«˜å…´çŸ¥é“**: æœªæ¥å°†æ·»åŠ æ›´å¤šåŠŸèƒ½ã€‚

</AppOnly>

## æœ€ä½ TypeScript ç‰ˆæœ¬

It is highly recommended to be on at least `v4.5.2` of TypeScript to get syntax features such as [type modifiers on import names](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#type-on-import-names) and [performance improvements](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#real-path-sync-native).

<AppOnly>

## é™æ€ç±»å‹çš„é“¾æ¥

Next.js å¯ä»¥é™æ€åœ°é”®å…¥é“¾æ¥ï¼Œä»¥é˜²æ­¢åœ¨ä½¿ç”¨`Next/link`æ—¶å‡ºç°æ‹¼å†™é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼Œä»è€Œæé«˜åœ¨é¡µé¢ä¹‹é—´å¯¼èˆªæ—¶çš„ç±»å‹å®‰å…¨æ€§ã€‚

è¦é€‰æ‹©ä½¿ç”¨æ­¤åŠŸèƒ½ï¼Œéœ€è¦å¯ç”¨`experimental.typedRoutes` ï¼Œå¹¶ä¸”é¡¹ç›®éœ€è¦ä½¿ç”¨ TypeScriptã€‚

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
};

module.exports = nextConfig;
```

Next.js will generate a link definition in `.next/types` that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links.

Currently, experimental support includes any string literal, including dynamic segments. For non-literal strings, you currently need to manually cast the `href` with `as Route`:

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// No TypeScript errors if href is a valid route
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// TypeScript errors if href is not a valid route
<Link href="/aboot" />
```

To accept `href` in a custom component wrapping `next/link`, use a generic:

```tsx
import type { Route } from "next";
import Link from "next/link";

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  );
}
```

> **How does it work?**
>
> When running `next dev` or `next build`, Next.js generates a hidden `.d.ts` file inside `.next` that contains information about all existing routes in your application (all valid routes as the `href` type of `Link`). This `.d.ts` file is included in `tsconfig.json` and the TypeScript compiler will check that `.d.ts` and provide feedback in your editor about invalid links.

## ç«¯åˆ°ç«¯å‹å®‰å…¨

Next.js 13 å…·æœ‰**å¢å¼ºå‹å®‰å…¨æ€§**ã€‚è¿™åŒ…æ‹¬ï¼š

1. **è·å–å‡½æ•°å’Œé¡µé¢ä¹‹é—´æ²¡æœ‰æ•°æ®åºåˆ—åŒ–**: You can `fetch` directly in components, layouts, and pages on the server. This data _does not_ need to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, since `app` uses Server Components by default, we can use values like `Date`, `Map`, `Set`, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types.
2. **ä¼˜åŒ–äº†ç»„ä»¶ä¹‹é—´çš„æ•°æ®æµ**: With the removal of `_app` in favor of root layouts, it is now easier to visualize the data flow between components and pages. Previously, data flowing between individual `pages` and `_app` were difficult to type and could introduce confusing bugs. With [colocated data fetching](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating) in Next.js 13, this is no longer an issue.

[Data Fetching in Next.js](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating) now provides as close to end-to-end type safety as possible without being prescriptive about your database or content provider selection.

We're able to type the response data as you would expect with normal TypeScript. For example:

```tsx filename="app/page.tsx"
async function getData() {
  const res = await fetch("https://api.example.com/...");
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.
  return res.json();
}

export default async function Page() {
  const name = await getData();

  return "...";
}
```

For _complete_ end-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through using an [ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping) or type-safe query builder.

## å¼‚æ­¥æœåŠ¡å™¨ç»„ä»¶ TypeScript é”™è¯¯

To use an `async` Server Component with TypeScript, ensure you are using TypeScript `5.1.3` or higher and `@types/react` `18.2.8` or higher.

If you are using an older version of TypeScript, you may see a `'Promise<Element>' is not a valid JSX element` type error. Updating to the latest version of TypeScript and `@types/react` should resolve this issue.

## åœ¨æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ç»„ä»¶ä¹‹é—´ä¼ é€’æ•°æ®

å½“é€šè¿‡é“å…·åœ¨æœåŠ¡å™¨ç»„ä»¶å’Œå®¢æˆ·ç«¯ç»„ä»¶ä¹‹é—´ä¼ é€’æ•°æ®æ—¶ï¼Œæ•°æ®ä»ç„¶è¢«åºåˆ—åŒ–ï¼ˆè½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼‰ä»¥åœ¨æµè§ˆå™¨ä¸­ä½¿ç”¨ã€‚ä½†æ˜¯ï¼Œå®ƒä¸éœ€è¦ç‰¹æ®Šç±»å‹ã€‚å®ƒçš„ç±»å‹ä¸åœ¨ç»„ä»¶ä¹‹é—´ä¼ é€’ä»»ä½•å…¶ä»–é“å…·ç›¸åŒã€‚

æ­¤å¤–ï¼Œéœ€è¦åºåˆ—åŒ–çš„ä»£ç æ›´å°‘ï¼Œå› ä¸ºæœªæ¸²æŸ“çš„æ•°æ®ä¸ä¼šåœ¨æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¹‹é—´äº¤å‰ï¼ˆå®ƒä¿ç•™åœ¨æœåŠ¡å™¨ä¸Šï¼‰ã€‚ç°åœ¨åªæœ‰é€šè¿‡æ”¯æŒæœåŠ¡å™¨ç»„ä»¶æ‰èƒ½åšåˆ°è¿™ä¸€ç‚¹ã€‚

</AppOnly>

<PagesOnly>

## é™æ€ç”Ÿæˆå’ŒæœåŠ¡å™¨ç«¯æ¸²æŸ“

For [`getStaticProps`](/docs/pages/api-reference/functions/get-static-props), [`getStaticPaths`](/docs/pages/api-reference/functions/get-static-paths), and [`getServerSideProps`](/docs/pages/api-reference/functions/get-server-side-props), you can use the `GetStaticProps`, `GetStaticPaths`, and `GetServerSideProps` types respectively:

```tsx filename="pages/blog/[slug].tsx"
import { GetStaticProps, GetStaticPaths, GetServerSideProps } from "next";

export const getStaticProps = (async (context) => {
  // ...
}) satisfies GetStaticProps;

export const getStaticPaths = (async () => {
  // ...
}) satisfies GetStaticPaths;

export const getServerSideProps = (async (context) => {
  // ...
}) satisfies GetServerSideProps;
```

> **Good to know:** `satisfies` was added to TypeScript in [4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html). We recommend upgrading to the latest version of TypeScript.

## API è·¯ç”±

ä»¥ä¸‹æ˜¯å¦‚ä½•ä¸º API è·¯ç”±ä½¿ç”¨å†…ç½®ç±»å‹çš„ç¤ºä¾‹ï¼š

```ts
import type { NextApiRequest, NextApiResponse } from "next";

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: "John Doe" });
}
```

You can also type the response data:

```ts
import type { NextApiRequest, NextApiResponse } from "next";

type Data = {
  name: string;
};

export default function handler(req: NextApiRequest, res: NextApiResponse<Data>) {
  res.status(200).json({ name: "John Doe" });
}
```

## è‡ªå®šä¹‰ `App`

If you have a [custom `App`](/docs/pages/building-your-application/routing/custom-app), you can use the built-in type `AppProps` and change file name to `./pages/_app.tsx` like so:

```ts
import type { AppProps } from "next/app";

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}
```

</PagesOnly>

## è·¯å¾„åˆ«åå’Œ baseUrl

Next.js automatically supports the `tsconfig.json` `"paths"` and `"baseUrl"` options.

<AppOnly>

You can learn more about this feature on the [Module Path aliases documentation](/docs/app/building-your-application/configuring/absolute-imports-and-module-aliases).

</AppOnly>

<PagesOnly>

You can learn more about this feature on the [Module Path aliases documentation](/docs/pages/building-your-application/configuring/absolute-imports-and-module-aliases).

</PagesOnly>

## ç±»å‹æ£€æŸ¥ next.config.js

`next.config.js`æ–‡ä»¶å¿…é¡»æ˜¯ JavaScript æ–‡ä»¶ï¼Œå› ä¸ºå®ƒä¸ä¼šè¢« Babel æˆ– TypeScript è§£æï¼Œä½†æ˜¯æ‚¨å¯ä»¥ä½¿ç”¨ JSDoc åœ¨ IDE ä¸­æ·»åŠ ä¸€äº›ç±»å‹æ£€æŸ¥ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```js
// @ts-check

/**
 * @type {import('next').NextConfig}
 **/
const nextConfig = {
  /* config options here */
};

module.exports = nextConfig;
```

## å¢é‡ç±»å‹æ£€æŸ¥

Since `v10.2.1` Next.js supports [incremental type checking](https://www.typescriptlang.org/tsconfig#incremental) when enabled in your `tsconfig.json`, this can help speed up type checking in larger applications.

## å¿½ç•¥ TypeScript é”™è¯¯

Next.js fails your **production build** (`next build`) when TypeScript errors are present in your project.

If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.

Open `next.config.js` and enable the `ignoreBuildErrors` option in the `typescript` config:

```js filename="next.config.js"
module.exports = {
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
};
```

## ç‰ˆæœ¬æ›´æ”¹

| Version   | Changes                                                                                                  |
| --------- | -------------------------------------------------------------------------------------------------------- |
| `v13.2.0` | é™æ€ç±»å‹çš„é“¾æ¥åœ¨æµ‹è¯•ç‰ˆä¸­å¯ç”¨ã€‚                                                                           |
| `v12.0.0` | [SWC](/docs/architecture/nextjs-compiler) ç°åœ¨é»˜è®¤ç”¨äºç¼–è¯‘ TypeScript å’Œ TSXï¼Œä»¥å®ç°æ›´å¿«çš„æ„å»ºã€‚         |
| `v10.2.1` | åœ¨`tsconfig.json`ä¸­å¯ç”¨æ—¶æ·»åŠ çš„[å¢é‡ç±»å‹æ£€æŸ¥](https://www.typescriptlang.org/tsconfig#incremental)æ”¯æŒã€‚ |
