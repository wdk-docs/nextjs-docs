---
title: TypeScript
description: Next.js provides a TypeScript-first development experience for building your React application.
---

{/* The content of this doc is shared between the app and pages router. You can use the `<PagesOnly>Content</PagesOnly>` component to add content that is specific to the Pages Router. Any shared content should not be wrapped in a component. */}

Next.js 为构建 React 应用程序提供了 TypeScript 第一次开发体验。

它内置 TypeScript 支持，可自动安装必要的软件包并配置正确的设置。

<AppOnly>

以及用于编辑器的[TypeScript 插件](#typescript-plugin)。

> **🎥 看:** 了解内置 TypeScript 插件 → [YouTube（3 分钟）](https://www.youtube.com/watch?v=pqMqn9fKEf8)

</AppOnly>

## 新项目

`create-next-app` 现在默认情况下附带 TypeScript。

```bash filename="Terminal"
npx create-next-app@latest
```

## 现有项目

Add TypeScript to your project by renaming a file to `.ts` / `.tsx`. Run `next dev` and `next build` to automatically install the necessary dependencies and add a `tsconfig.json` file with the recommended config options.

If you already had a `jsconfig.json` file, copy the `paths` compiler option from the old `jsconfig.json` into the new `tsconfig.json` file, and delete the old `jsconfig.json` file.

<AppOnly>

## TypeScript 插件

Next.js 包括一个自定义的 TypeScript 插件和类型检查器，VSCode 和其他代码编辑器可以使用它进行高级类型检查和自动完成。

您可以通过以下方式在 VS Code 中启用插件：

1. 打开命令选项板 (`Ctrl/⌘` + `Shift` + `P`)
2. 正在搜索"TypeScript: Select TypeScript Version"
3. 选择 "Use Workspace Version"

<Image
  alt="TypeScript Command Palette"
  srclight="/docs/light/typescript-command-palette.png"
  srcdark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

现在，在编辑文件时，将启用自定义插件。运行`next build`时，将使用自定义类型检查器。

### 插件功能

TypeScript 插件可以帮助：

- 如果传递了[段配置选项](/docs/app/api-reference/file-conventions/route-segment-config)的无效值，则发出警告。
- 显示可用选项和上下文中的文档。
- 确保正确使用`use client`指令。
- 确保客户端挂钩（如`useState`）仅在客户端组件中使用。

> **很高兴知道**: 未来将添加更多功能。

</AppOnly>

## 最低 TypeScript 版本

It is highly recommended to be on at least `v4.5.2` of TypeScript to get syntax features such as [type modifiers on import names](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#type-on-import-names) and [performance improvements](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#real-path-sync-native).

<AppOnly>

## 静态类型的链接

Next.js 可以静态地键入链接，以防止在使用`Next/link`时出现拼写错误和其他错误，从而提高在页面之间导航时的类型安全性。

要选择使用此功能，需要启用`experimental.typedRoutes` ，并且项目需要使用 TypeScript。

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
};

module.exports = nextConfig;
```

Next.js will generate a link definition in `.next/types` that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links.

Currently, experimental support includes any string literal, including dynamic segments. For non-literal strings, you currently need to manually cast the `href` with `as Route`:

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// No TypeScript errors if href is a valid route
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// TypeScript errors if href is not a valid route
<Link href="/aboot" />
```

To accept `href` in a custom component wrapping `next/link`, use a generic:

```tsx
import type { Route } from "next";
import Link from "next/link";

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  );
}
```

> **How does it work?**
>
> When running `next dev` or `next build`, Next.js generates a hidden `.d.ts` file inside `.next` that contains information about all existing routes in your application (all valid routes as the `href` type of `Link`). This `.d.ts` file is included in `tsconfig.json` and the TypeScript compiler will check that `.d.ts` and provide feedback in your editor about invalid links.

## 端到端型安全

Next.js 13 具有**增强型安全性**。这包括：

1. **获取函数和页面之间没有数据序列化**: You can `fetch` directly in components, layouts, and pages on the server. This data _does not_ need to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, since `app` uses Server Components by default, we can use values like `Date`, `Map`, `Set`, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types.
2. **优化了组件之间的数据流**: With the removal of `_app` in favor of root layouts, it is now easier to visualize the data flow between components and pages. Previously, data flowing between individual `pages` and `_app` were difficult to type and could introduce confusing bugs. With [colocated data fetching](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating) in Next.js 13, this is no longer an issue.

[Data Fetching in Next.js](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating) now provides as close to end-to-end type safety as possible without being prescriptive about your database or content provider selection.

We're able to type the response data as you would expect with normal TypeScript. For example:

```tsx filename="app/page.tsx"
async function getData() {
  const res = await fetch("https://api.example.com/...");
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.
  return res.json();
}

export default async function Page() {
  const name = await getData();

  return "...";
}
```

For _complete_ end-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through using an [ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping) or type-safe query builder.

## 异步服务器组件 TypeScript 错误

To use an `async` Server Component with TypeScript, ensure you are using TypeScript `5.1.3` or higher and `@types/react` `18.2.8` or higher.

If you are using an older version of TypeScript, you may see a `'Promise<Element>' is not a valid JSX element` type error. Updating to the latest version of TypeScript and `@types/react` should resolve this issue.

## 在服务器和客户端组件之间传递数据

当通过道具在服务器组件和客户端组件之间传递数据时，数据仍然被序列化（转换为字符串）以在浏览器中使用。但是，它不需要特殊类型。它的类型与在组件之间传递任何其他道具相同。

此外，需要序列化的代码更少，因为未渲染的数据不会在服务器和客户端之间交叉（它保留在服务器上）。现在只有通过支持服务器组件才能做到这一点。

</AppOnly>

<PagesOnly>

## 静态生成和服务器端渲染

For [`getStaticProps`](/docs/pages/api-reference/functions/get-static-props), [`getStaticPaths`](/docs/pages/api-reference/functions/get-static-paths), and [`getServerSideProps`](/docs/pages/api-reference/functions/get-server-side-props), you can use the `GetStaticProps`, `GetStaticPaths`, and `GetServerSideProps` types respectively:

```tsx filename="pages/blog/[slug].tsx"
import { GetStaticProps, GetStaticPaths, GetServerSideProps } from "next";

export const getStaticProps = (async (context) => {
  // ...
}) satisfies GetStaticProps;

export const getStaticPaths = (async () => {
  // ...
}) satisfies GetStaticPaths;

export const getServerSideProps = (async (context) => {
  // ...
}) satisfies GetServerSideProps;
```

> **Good to know:** `satisfies` was added to TypeScript in [4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html). We recommend upgrading to the latest version of TypeScript.

## API 路由

以下是如何为 API 路由使用内置类型的示例：

```ts
import type { NextApiRequest, NextApiResponse } from "next";

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: "John Doe" });
}
```

You can also type the response data:

```ts
import type { NextApiRequest, NextApiResponse } from "next";

type Data = {
  name: string;
};

export default function handler(req: NextApiRequest, res: NextApiResponse<Data>) {
  res.status(200).json({ name: "John Doe" });
}
```

## 自定义 `App`

If you have a [custom `App`](/docs/pages/building-your-application/routing/custom-app), you can use the built-in type `AppProps` and change file name to `./pages/_app.tsx` like so:

```ts
import type { AppProps } from "next/app";

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}
```

</PagesOnly>

## 路径别名和 baseUrl

Next.js automatically supports the `tsconfig.json` `"paths"` and `"baseUrl"` options.

<AppOnly>

You can learn more about this feature on the [Module Path aliases documentation](/docs/app/building-your-application/configuring/absolute-imports-and-module-aliases).

</AppOnly>

<PagesOnly>

You can learn more about this feature on the [Module Path aliases documentation](/docs/pages/building-your-application/configuring/absolute-imports-and-module-aliases).

</PagesOnly>

## 类型检查 next.config.js

`next.config.js`文件必须是 JavaScript 文件，因为它不会被 Babel 或 TypeScript 解析，但是您可以使用 JSDoc 在 IDE 中添加一些类型检查，如下所示：

```js
// @ts-check

/**
 * @type {import('next').NextConfig}
 **/
const nextConfig = {
  /* config options here */
};

module.exports = nextConfig;
```

## 增量类型检查

Since `v10.2.1` Next.js supports [incremental type checking](https://www.typescriptlang.org/tsconfig#incremental) when enabled in your `tsconfig.json`, this can help speed up type checking in larger applications.

## 忽略 TypeScript 错误

Next.js fails your **production build** (`next build`) when TypeScript errors are present in your project.

If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.

Open `next.config.js` and enable the `ignoreBuildErrors` option in the `typescript` config:

```js filename="next.config.js"
module.exports = {
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
};
```

## 版本更改

| Version   | Changes                                                                                                  |
| --------- | -------------------------------------------------------------------------------------------------------- |
| `v13.2.0` | 静态类型的链接在测试版中可用。                                                                           |
| `v12.0.0` | [SWC](/docs/architecture/nextjs-compiler) 现在默认用于编译 TypeScript 和 TSX，以实现更快的构建。         |
| `v10.2.1` | 在`tsconfig.json`中启用时添加的[增量类型检查](https://www.typescriptlang.org/tsconfig#incremental)支持。 |
