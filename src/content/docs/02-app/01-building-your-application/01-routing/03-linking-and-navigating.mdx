---
title: 链接和导航
description: 了解导航在Next.js中的工作原理，以及如何使用链接组件和`useRouter`挂钩。
related:
  links:
    - app/building-your-application/caching
    - app/building-your-application/configuring/typescript
---

在 Next.js 中，有两种方法可以在路线之间导航：

- Using the [`<Link>` Component](#link-component)
- Using the [`useRouter` Hook](#userouter-hook)

This page will go through how to use `<Link>`, `useRouter()`, and dive deeper into how navigation works.

## `<Link>` 组件

`<Link>` is a built-in component that extends the HTML `<a>` tag to provide [prefetching](#1-prefetching) and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.

You can use it by importing it from `next/link`, and passing a `href` prop to the component:

```tsx filename="app/page.tsx" switcher
import Link from "next/link";

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>;
}
```

```jsx filename="app/page.js" switcher
import Link from "next/link";

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>;
}
```

There are other optional props you can pass to `<Link>`. See the [API reference](/docs/app/api-reference/components/link) for more.

### 示例

#### 链接到动态分段

When linking to [dynamic segments](/docs/app/building-your-application/routing/dynamic-routes), you can use [template literals and interpolation](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals) to generate a list of links. For example, to generate a list of blog posts:

```jsx filename="app/blog/PostList.js"
import Link from "next/link";

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  );
}
```

#### 检查活动链接

You can use [`usePathname()`](/docs/app/api-reference/functions/use-pathname) to determine if a link is active. For example, to add a class to the active link, you can check if the current `pathname` matches the `href` of the link:

```tsx filename="app/components/links.tsx" switcher
"use client";

import { usePathname } from "next/navigation";
import Link from "next/link";

export function Links() {
  const pathname = usePathname();

  return (
    <nav>
      <ul>
        <li>
          <Link className={`link ${pathname === "/" ? "active" : ""}`} href="/">
            Home
          </Link>
        </li>
        <li>
          <Link className={`link ${pathname === "/about" ? "active" : ""}`} href="/about">
            About
          </Link>
        </li>
      </ul>
    </nav>
  );
}
```

```jsx filename="app/components/links.js" switcher
"use client";

import { usePathname } from "next/navigation";
import Link from "next/link";

export function Links() {
  const pathname = usePathname();

  return (
    <nav>
      <ul>
        <li>
          <Link className={`link ${pathname === "/" ? "active" : ""}`} href="/">
            Home
          </Link>
        </li>
        <li>
          <Link className={`link ${pathname === "/about" ? "active" : ""}`} href="/about">
            About
          </Link>
        </li>
      </ul>
    </nav>
  );
}
```

#### 滚动到 `id`

The default behavior of the Next.js App Router is to scroll to the top of a new route or to maintain the scroll position for backwards and forwards navigation.

If you'd like to scroll to a specific `id` on navigation, you can append your URL with a `#` hash link or just pass a hash link to the `href` prop. This is possible since `<Link>` renders to an `<a>` element.

```jsx
<Link href="/dashboard#settings">Settings</Link>

// Output
<a href="/dashboard#settings">Settings</a>
```

#### 禁用滚动恢复

The default behavior of the Next.js App Router is to scroll to the top of a new route or to maintain the scroll position for backwards and forwards navigation. If you'd like to disable this behavior, you can pass `scroll={false}` to the `<Link>` component, or `scroll: false` to `router.push()` or `router.replace()`.

```jsx
// next/link
<Link href="/dashboard" scroll={false}>
  Dashboard
</Link>
```

```jsx
// useRouter
import { useRouter } from "next/navigation";

const router = useRouter();

router.push("/dashboard", { scroll: false });
```

## `useRouter()` 钩子

`useRouter`挂钩允许您以编程方式更改路由。

此挂钩只能在客户端组件内部使用，并从`next/navigation`导入。

```jsx filename="app/page.js"
"use client";

import { useRouter } from "next/navigation";

export default function Page() {
  const router = useRouter();

  return (
    <button type="button" onClick={() => router.push("/dashboard")}>
      Dashboard
    </button>
  );
}
```

有关`useRouter`方法的完整列表，请参阅[API 参考](/docs/app/api-reference/functions/use-router).

> **正式建议:** 使用`<Link>`组件在路线之间导航，除非您有使用`useRouter`的特定要求。

## 路由和导航的工作原理

The App Router uses a hybrid approach for routing and navigation. On the server, your application code is automatically code-split by route segments. And on the client, Next.js [prefetches](#1-prefetching) and [caches](#2-caching) the route segments. This means, when a user navigates to a new route, the browser doesn't reload the page, and only the route segments that change re-render - improving the navigation experience and performance.

### 1. 预取

预取是在用户访问路由之前在后台预加载路由的一种方式。

Next.js 中有两种预取路由的方式：

- **`<Link>` component**: 当路由在用户的视口中可见时，会自动预取这些路由。当页面首次加载或通过滚动进入视图时，会发生预取。
- **`router.prefetch()`**: `useRouter`挂钩可用于以编程方式预取路由。

静态路由和动态路由的`<Link>`预取行为不同：

- [**静态路由**](/docs/app/building-your-application/rendering/server-components#static-rendering-default): `prefetch` defaults to `true`. The entire route is prefetched and cached.
- [**动态路线**](/docs/app/building-your-application/rendering/server-components#dynamic-rendering): `prefetch` default to automatic. Only the shared layout down until the first `loading.js` file is prefetched and cached for `30s`. This reduces the cost of fetching an entire dynamic route, and it means you can show an [instant loading state](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states) for better visual feedback to users.

You can disable prefetching by setting the `prefetch` prop to `false`.

See the [`<Link>` API reference](/docs/app/api-reference/components/link) for more information.

> **Good to know**:
>
> - Prefetching is not enabled in development, only in production.

### 2. 缓存

Next.js has an **in-memory client-side cache** called the [Router Cache](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#caching-data#router-cache). As users navigate around the app, the React Server Component Payload of [prefetched](#1-prefetching) route segments and visited routes are stored in the cache.

This means on navigation, the cache is reused as much as possible, instead of making a new request to the server - improving performance by reducing the number of requests and data transferred.

Learn more about how the [Router Cache](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#caching-data) works and how to configure it.

### 3. 局部渲染

部分渲染意味着只有在导航时发生更改的路由段才会在客户端上重新渲染，并且任何共享管段都会保留。

For example, when navigating between two sibling routes, `/dashboard/settings` and `/dashboard/analytics`, the `settings` and `analytics` pages will be rendered, and the shared `dashboard` layout will be preserved.

<Image
  alt="How partial rendering works"
  srclight="/docs/light/partial-rendering.png"
  srcdark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

如果没有部分渲染，每个导航都会导致整个页面在服务器上重新渲染。仅渲染发生更改的段可以减少传输的数据量和执行时间，从而提高性能。

### 4. 软导航

默认情况下，浏览器在页面之间执行硬导航。这意味着浏览器会重新加载页面并重置 React 状态，如应用程序中的`useState`挂钩，以及浏览器状态，如用户的滚动位置或聚焦元素。然而，在 Next.js 中，应用程序路由器使用软导航。这意味着 React 只渲染已更改的片段，同时保留 React 和浏览器状态，并且不重新加载整个页面。

### 5. 前后导航

默认情况下，Next.js 将保持向后和向前导航的滚动位置，并重复使用[路由器缓存](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#caching-data)中的路由段.
