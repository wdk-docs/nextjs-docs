---
title: 快速刷新
description: 快速刷新是一种热模块重新加载体验，它可以为您提供对React组件所做编辑的即时反馈。
---

快速刷新是 Next.js 的一个功能，它可以为您的 React 组件的编辑提供即时反馈。默认情况下，**9.4 或更新版本**上的所有 Next.js 应用程序都会启用`快速刷新`。启用 Next.js 快速刷新后，大多数编辑应在一秒内可见，**而不会丢失组件状态**。

## 它的工作原理

- 如果您编辑的文件**仅导出 React 组件**，`快速刷新`将仅更新该文件的代码，并重新渲染组件。您可以编辑该文件中的任何内容，包括样式、渲染逻辑、事件处理程序或效果。
- 如果您编辑的文件的导出*不*是 React 组件，则`快速刷新`将重新运行该文件和导入该文件的其他文件。因此，如果`Button.js`和`Modal.js`都导入`theme.js`，则编辑`theme.js`将更新这两个组件。
- 最后, 如果您**编辑由 React 树之外的文件导入的文件**, 快速刷新**将回退到进行完全重新加载**. 您可能有一个文件，该文件呈现 React 组件，但也导出由**非 React 组件**导入的值。例如，也许您的组件也导出了一个常量，而非 React 实用程序文件导入了它。在这种情况下，请考虑将常量迁移到一个单独的文件中，然后将其导入两个文件中。这将重新启用`快速刷新`。其他情况通常可以用类似的方式解决。

## 错误恢复能力

### 语法错误

如果在开发过程中出现语法错误，可以修复它并重新保存文件。错误将自动消失，因此您不需要重新加载应用程序。 **您不会丢失组件状态**.

### 运行期错误

如果您犯了一个错误，导致组件内部出现运行时错误，您将收到一个上下文覆盖。修复错误将自动取消覆盖，而无需重新加载应用程序。

如果在渲染过程中没有发生错误，则组件状态将被保留。如果在渲染期间确实发生了错误，React 将使用更新的代码重新安装应用程序。

如果你的应用程序中有[错误边界](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)(这对生产中的正常故障来说是个好主意)，在出现渲染错误后，他们将在下一次编辑时重试渲染。这意味着有一个错误边界可以防止您总是重置到根应用程序状态。但是，请记住，错误边界不应该太细。它们由 React 在生产中使用，并且应该始终是有意设计的。

## 局限性

Fast Refresh 尝试在您正在编辑的组件中保留本地 React 状态，但前提是这样做是安全的。以下是您可能在每次编辑文件时看到本地状态被重置的几个原因：

- 类组件不保留局部状态(只有函数组件和 Hooks 保留状态)。
- 除了 React 组件之外，您正在编辑的文件可能还有其他导出(\_O)。
- 有时，文件会导出调用高阶组件(如`HOC(WrappedComponent)`)的结果。如果返回的组件是一个类，则其状态将被重置。
- 匿名箭头函数如 `export default () => <div />;`导致`快速刷新`不保留本地组件状态. 对于大型代码库，您可以使用我们的 [`name-default-component` codemod](/docs/pages/building-your-application/upgrading/codemods#name-default-component).

随着越来越多的代码库转移到函数组件和 Hook，您可以期望在更多情况下保留状态。

## Tips

- 默认情况下，快速刷新会在功能组件(和挂钩)中保留 React 本地状态。
- 有时，您可能希望强制重置状态，并重新装入组件。例如，如果您正在调整仅在装载时发生的动画，这将非常方便。为此，您可以在正在编辑的文件中的任何位置添加`// @refresh reset` 。此指令是文件的本地指令，并指示`快速刷新`在每次编辑时重新装载该文件中定义的组件。
- 您可以放置`console.log`或`debugger；`到您在开发过程中编辑的组件中。
- 请记住，导入是区分大小写的。当导入与实际文件名不匹配时，快速刷新和完全刷新都可能失败。例如 `'./header'` vs `'./Header'`.

## 快速刷新和挂钩

如果可能，`快速刷新`会尝试在两次编辑之间保留零部件的状态。 特别是，只要不更改它们的参数或 Hook 调用的顺序，`useState`和`useRef`就会保留它们以前的值。

具有依赖关系的挂钩——例如 `useEffect`, `useMemo`, 和 `useCallback`—将在快速刷新期间*始终*更新. 在进行快速刷新时，它们的依赖项列表将被忽略。

例如, 编辑时 `useMemo(() => x * 2, [x])` 到 `useMemo(() => x * 10, [x])`, 即使`x`(依赖项)没有改变，它也将重新运行。如果 React 不这么做，你的编辑就不会反映在屏幕上！

有时，这会导致意想不到的结果。例如，即使是具有空依赖项数组的`useEffect`，在快速刷新期间仍会重新运行一次。

然而，即使没有`快速刷新`，编写能够抵御偶尔重新运行`useEffect`的代码也是一种很好的做法。它将使您稍后更容易向它引入新的依赖项，并且它由[React 严格模式](/docs/pages/api-reference/next-config-js/reactStrictMode)强制执行，我们强烈建议启用它。
